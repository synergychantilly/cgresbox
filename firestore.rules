rules_version='2'

service cloud.firestore {
  match /databases/{database}/documents {
    // Helper functions
    function isAuthenticated() {
      return request.auth != null;
    }
    
    function getUserData() {
      return get(/databases/$(database)/documents/users/$(request.auth.uid)).data;
    }
    
    function isAdmin() {
      return isAuthenticated() && getUserData().role == 'admin';
    }
    
    function isApprovedUser() {
      return isAuthenticated() && getUserData().status == 'approved';
    }
    
    function isAdminOrOwner(userId) {
      return isAdmin() || request.auth.uid == userId;
    }

    // Users collection
    match /users/{userId} {
      // Users can read their own data, admins can read all
      allow read: if isAdminOrOwner(userId);
      
      // Allow authenticated users to create their own user document
      // Special case: allow admin user creation during setup
      allow create: if isAuthenticated() && request.auth.uid == userId && (
        (request.resource.data.role == 'user' && request.resource.data.status == 'pending') ||
        (request.resource.data.role == 'admin' && request.resource.data.status == 'approved' && 
         request.resource.data.email == 'hashimosman@synergyhomecare.com')
      );
      
      // Admins can update any user, users can update their own limited fields
      allow update: if isAdmin() || 
        (request.auth.uid == userId && 
         !('role' in request.resource.data.diff(resource.data).affectedKeys()) &&
         !('status' in request.resource.data.diff(resource.data).affectedKeys()));
      
      // Only admins can delete users
      allow delete: if isAdmin();
    }

    // User actions (audit log)
    match /userActions/{actionId} {
      allow read: if isAdmin();
      allow create: if isAdmin();
      allow update, delete: if false; // Audit logs should be immutable
    }

    // Calendar events
    match /calendarEvents/{eventId} {
      allow read: if isApprovedUser();
      allow write: if isAdmin();
    }

    // Announcements/Updates
    match /announcements/{announcementId} {
      allow read: if isApprovedUser();
      allow write: if isAdmin();
    }

    // Resources
    match /resources/{resourceId} {
      allow read: if isApprovedUser();
      allow write: if isAdmin();
    }

    // Questions
    match /questions/{questionId} {
      allow read: if isApprovedUser();
      allow create: if isApprovedUser() && request.auth.uid == request.resource.data.author;
      allow update: if isAdmin() || 
        (isApprovedUser() && request.auth.uid == resource.data.author && 
         // Users can only update content-related fields on their own questions
         !('title' in request.resource.data.diff(resource.data).affectedKeys()) &&
         !('content' in request.resource.data.diff(resource.data).affectedKeys()) &&
         !('category' in request.resource.data.diff(resource.data).affectedKeys())) ||
        (isApprovedUser() && 
         // Any approved user can update upvotes, upvotedBy, isAnswered
         request.resource.data.diff(resource.data).affectedKeys().hasOnly(['upvotes', 'upvotedBy', 'isAnswered', 'updatedAt']));
      allow delete: if isAdmin();
    }

    // Answers (top-level collection)
    match /answers/{answerId} {
      allow read: if isApprovedUser();
      allow create: if isApprovedUser() && request.auth.uid == request.resource.data.author;
      allow update: if isAdmin() || 
        (isApprovedUser() && request.auth.uid == resource.data.author &&
         // Users can only update content on their own answers
         !('content' in request.resource.data.diff(resource.data).affectedKeys())) ||
        (isApprovedUser() && 
         // Any approved user can update upvotes, upvotedBy, isAccepted
         request.resource.data.diff(resource.data).affectedKeys().hasOnly(['upvotes', 'upvotedBy', 'isAccepted', 'updatedAt']));
      allow delete: if isAdmin() || 
        (isApprovedUser() && request.auth.uid == resource.data.author);
    }

    // Edit Requests
    match /editRequests/{requestId} {
      allow read: if isAdmin() || 
        (isApprovedUser() && request.auth.uid == resource.data.requestedBy);
      allow create: if isApprovedUser() && request.auth.uid == request.resource.data.requestedBy;
      allow update: if isAdmin(); // Only admins can approve/reject requests
      allow delete: if isAdmin();
    }

    // Notifications
    match /notifications/{notificationId} {
      allow read: if isApprovedUser() && request.auth.uid == resource.data.userId;
      allow create: if isAdmin(); // Only system/admins create notifications
      allow update: if isApprovedUser() && request.auth.uid == resource.data.userId &&
        // Users can only mark as read
        request.resource.data.diff(resource.data).affectedKeys().hasOnly(['isRead']);
      allow delete: if isAdmin() || 
        (isApprovedUser() && request.auth.uid == resource.data.userId);
    }

    // Complaints
    match /complaints/{complaintId} {
      allow read: if isAdmin() || 
        (isApprovedUser() && request.auth.uid == resource.data.submittedBy);
      allow create: if isApprovedUser() && request.auth.uid == request.resource.data.submittedBy;
      allow update: if isAdmin() || 
        (isApprovedUser() && request.auth.uid == resource.data.submittedBy && 
         resource.data.status == 'submitted');
      allow delete: if isAdmin();
    }

    // Document Categories
    match /documentCategories/{categoryId} {
      allow read: if isApprovedUser() || true; // Allow new hires to read categories
      allow write: if isAdmin();
    }

    // Document Templates
    match /documentTemplates/{templateId} {
      allow read: if isApprovedUser() || true; // Allow new hires to read templates
      allow write: if isAdmin();
    }

    // Helper function to check if user is a new hire with valid session
    function isNewHireWithValidSession() {
      // For new hires, we'll need to validate their session separately
      // Since they don't have Firebase auth, this will be handled at the application level
      return false; // New hires will access documents through admin-created records
    }

    // User Document Status (new system)
    match /userDocuments/{userDocId} {
      allow read: if isAdmin() || 
        (isApprovedUser() && request.auth.uid == resource.data.userId) ||
        true; // Allow new hires to read their documents
      allow create: if isAdmin() || 
        (isApprovedUser() && request.auth.uid == request.resource.data.userId) ||
        true; // Allow new hires to create document statuses
      allow update: if isAdmin() || 
        (isApprovedUser() && request.auth.uid == resource.data.userId) ||
        true; // Allow new hires to update their document statuses
      allow delete: if isAdmin();
    }

    // Document Webhook Events (for system use)
    match /documentWebhookEvents/{eventId} {
      allow read: if isAdmin();
      allow create: if true; // Allow webhook service to create events
      allow update: if isAdmin();
      allow delete: if isAdmin();
    }

    // Legacy Documents (keep for backward compatibility)
    match /documents/{documentId} {
      allow read: if isApprovedUser();
      allow write: if isAdmin();
    }

    // New Hires
    match /newHires/{newHireId} {
      allow read: if true; // Allow all reads for new hire verification
      allow write: if isAdmin();
    }

    // New Hire Sessions (for temporary access)
    match /newHireSessions/{sessionId} {
      allow read: if true; // Allow reading for session validation
      allow create: if true; // Allow creating sessions during new hire login
      allow update: if true; // Allow updating session status
      allow delete: if isAdmin(); // Only admins can delete sessions
    }

    // Block access to all other collections
    match /{document=**} {
      allow read, write: if false;
    }
  }
}
